# 10. Execution plan

- 대부분의 DBMS는 많은 데이터를 안전하게 저장 및 관리하고 사용자가 원하는 데이터를 빠르게 조회할 수 있게 해주는 것이 주목적이다. 이러한 목적을 달성하려면 옵티마이저가 사용자의 사용자의 쿼리를 최적으로 처리될 수 있게 하는 쿼리의 실행 계획을 수립할 수 있어야 한다.
- DBMS서버는 좋은 실행계획을 만들 수 있도록 EXPLAIN 명령으로 옵티마이저가 수립한 실행 계획을 확인할 수 있다.

<br/>

## **목차**
- [10.1.1 테이블 및 인덱스 통계 정보](#1)
- [10.1.2 히스토그램](#2)
- [10.1.3 코스트 모델(Cost Model)](#3)

<br/>

# **`10.1 통계 정보`**
MySQL 서버는 5.7 버전까지 테이블과 인덱스에 대한 개괄적인 정보를 가지고 실행계획을 수립했다.  
하지만 이는 테이블 칼럼의 값들이 실제 어떻게 분포돼 있는지에 대한 정보가 없기 때문에 실행 계획의 정확도가 떨어지는 경우가 많았다. 그래서 MySQL 8.0 버전부터는 인덱스되지 않은 칼럼들에 대해서도 데이터 분포도를 수집해서 저장하는 히스토그램(Histogram) 정보가 도입됐다. 히스토그램이 도입됐다고 해서 기존의 테이블이나 인덱스의 통계 정보가 필요치 않은 것은 아니다.

<br/>

## **`10.1.1 테이블 및 인덱스 통계 정보`**<a id="1"></a>
비용 기반 최적화에서 가장 중요한 것은 통계 정보다. 통계 정보가 정확하지 않다면 전혀 엉뚱한 방향으로 쿼리를 실행할 수가 있기 대문이다.

MySQL 또한 다른 DBMS와 같이 비용 기반의 최적화를 사용하지만, 다른 DBMS보다 통계 정보의 정확도가 높지 않고 통계 정보의 휘발성이 강했다. 그래서 MySQL 서버에서는 쿼리의 실행 계획을 수립할 때 실제 테이블의 데이터를 일부 분석해서 통계 정보를 보완해서 사용했다. 이러한 이유로 MySQL 5.6 버전부터는 통계 정보의 정확성을 높일 수 있는 방법기 제공되기 시작했지만 아직도 많은 사용자가 기존 방식을 그대로 사용한다.

<br/>

### **`MySQL 서버의 통계 정보`**
MySQL 5.6 버전부터는 InnoDB 스토리지 엔진을 사용하는 테이블에 대한 통꼐 정보를 영구적으로(Persistent) 관리할 수 있게 개선 됐다.  
MySQL 5.5 버전까지는 각 테이블의 통계 정보가 메모리에만 관리되고, SHOW INDEX 명령으로만 테이블의 인덱스 칼럼의 분포도를 볼 수 있었다. 통계정보가 메모리에 관리될 경우 MySQL 서버가 재시작되면 수집된 통계 정보가 모두 사라진다.

MySQL 5.6 버전부터는 각 테이블의 통계 정보를 mysql 데이터베이스의 innodb_index_stats 테이블과 innodb_table_stats 테이블로 관리할 수 있게 개선됐다.

MySQL 5.6에서 테이블을 생성할 때는 STATS_PERSISTENT 옵션을 설정할 수 있는데, 이 설정값에 따라 테이블 단위로 영구적인 통계 정보를 보관할지 결정할 수 있다.
- STATS_PERSISTENT=0 : 테이블의 통계 정보를 MySQL 5.5 이전의 방식대로 관리하며, mysql 데이터베이스의 innodb_index_stats와 innodb_table_stats 테이블에 저장하지 않음.
- STATS_PERSISTENT=1 : 테이블의 통계 정보를 mysql 데이터베이스의 innodb_index_stats와 innodb_table_stats 테이블에 저장함
- STATS_PERSISTENT=2 : 테이블을 생성할 때 별도로 STATS_PERSISTENT 옵션을 설정하지 않은 것과 동일하며, 테이블의 통계를 영구적으로 관리할지 말지를 innodb_stats_persistent 시스템 변수의 값으로 결정한다.

innodb_stats_persistent 시스템 설정 변수는 기본적으로 ON(1)으로 설정돼 있으며, STATS_PERSISTENT 옵션 없이 테이블을 생성하면 영구적인 통계 정보를 사용하면서 innodb_index_stats 테이블과 innodb_table_stats 테이블에 통계 정보를 저장한다.

통계 정보의 각 칼럼은 다음과 같은 값을 저장하고 있다.
- innodb_index_stats table
    - stat_name='n_diff_pfx%' : 인덱스가 가진 유니크한 값의 개수
    - stat_name='n_leaf_pages' : 인덱스의 리프 노드 페이지 개수
    - stat_name='size' : 인덱스 트리의 전체 페이지 개수
    - n_rows : 테이블의 전체 레코드 건수
    - clustered_index : 프라이머리 키의 크기(innoDB 페이지 개수)
    - sum_of_other_index_sizes : 프라이머리 키를 제외한 인덱스의 크기(InnoDB 페이지 개수)

<br/>

MySQL 5.5 버전까지는 테이블의 통계 정보가 메모리에만 저장되며, MySQL 서버가 재시작되면 통계 정보가 초기화됐다. 그래서 MySQL 서버가 시작되면 모든 테이블의 통계 정보는 다시 수집돼야 했다. 그리고 아래와 같은 이벤트가 발생하면 자동으로 통계 정보가 갱신됐다.
- 테이블이 새로 오픈되는 경우
- 테이블의 레코드가 대량으로 변경되는 경우(테이블의 전체 레코드 중에서 1/16 정도의 UPDATE 또는 INSERT나 DELETE가 실행되는 경우)
- ANALYZE TABLE 명령이 실행되는 경우
- SHOW TABLE STATUS 명령이나 SHOW INDEX FROM 명령이 실행되는 경우
- InnoDB 모니터가 활성화되는 경우
- innodb_stats_on_metadata 시스템 설정이 ON인 상태에서 SHOW TABLE STATUS 명령이 실행되는 경우

<br/>

innodb_stats_auto_recalc 시스템 설정 변수의 값을 OFF로 설정해서 통계 정보가 자동으로 갱신되는 것을 막을 수 있다. 해당 변수의 기본값은 ON이다.

통계 정보를 자동으로 수집할지 여부도 테이블을 생성할 때 STATS_AUTO_RECALC 옵션을 통해 테이블 단위로 조정할 수 있다.

- STATS_AUTO_RECALC=1 : 테이블의 통계 정보를 MySQL 5.5 이전의 방식대로 자동 수집한다.
- STATS_AUTO_RECALC=2 : 테이블의 통계 정보는 ANALYZE TABLE 명령을 실행할 때만 수집된다.
- STATS_AUTO_RECALC=DEFAULT : 테이블을 생성할 때 별도로 STATS_AUTO_RECALC 옵션을 설정하지 않은 것과 동일하며, 테이블의 통계 정보 수집을 innodb_stats_auto_recalc 시스템 설정 변수의 값으로 결정한다.

<br/>

통계 정보를 수집할 때 몇 개의 InnoDB 테이블 블록을 샘플링할지 결정하는 시스템 변수는 아래와 같다.
- innodb_stats_transient_sample_pages
    - 이 시스템 변수의 기본값은 8인데, 이는 자동으로 통계 정보 수집이 실행될 때 8개 페이지만 임의로 샘플링해서 분석하고 그 결과를 통계 정보로 활용함을 의미한다.
- innodb_stats_persistent_sample_pages
    - 기본값은 20이며, ANALYZE TABLE 명령이 실행되면 임의로 20개 페이지만 샘플링해서 분석하고 그 결과를 영구적인 통계 정보 테이블에 저장하고 활용함을 의미한다.

<br/>

## **`10.1.2 히스토그램`**<a id="2"></a>
MySQL 5.7 버전까지의 통계 정보는 단순히 인덱스된 칼럼의 유니크한 값의 개수 정도만 가지고 있었는데, 이는 옵티마이저가 최적의 실행 계획을 수립하기에는 많이 부족했다. 그래서 옵티마이저는 이러한 부족함을 메우기 위해 실행 계획을 수립할 때 실제 인덱스의 일부 페이지를 랜덤으로 가져와 참조하는 방식을 사용했다.  
8.0 버전으로 업그레이드 되면서 MySQL 서버도 드디어 칼럼의 데이터 분포도를 참조하라 수 있는 히스토그램(Hisogram) 정보를 활용할 수 있게 됐다.

<br/>

### **`히스토그램 정보 수집 및 삭제`**
