# 08. Index

- 인덱스는 테이버베이스 쿼리의 성능을 언급하면서 빼놓을 수 없는 부분
- 각 인덱스의 특성과 차이는 상당히 중요하며, 물리 수준의 모델링을 할 때도 중요한 요소가 될 것이다.
- 인덱스는 쿼리 튜닝의 기본이 된다.

<br/>

## **목차**
- [8.8.1 클러스터링 인덱스](#1)
- [8.8.2 세컨더리 인덱스에 미치는 영향](#2)
- [8.8.3 클러스터링 인덱스의 장점과 단점](#3)
- [8.8.4 클러스터링 테이블 사용 시 주의사항](#4)

<br/>

# **`8.8 클러스터링 인덱스`**
클러스터링이란 여러 개를 하나로 묶는다는 의미로 주로 사용되는데, MySQL 에서의 클러스터링은 테이블의 레코드를 비슷한 것(프라이머리 키를 기준으로)들 끼리 묶어서 저장하는 형태로 구현된다. InnoDB 스토리지 엔진에서만 지원한다.
<br/>

## **`8.8.1 클러스터링 인덱스`**<a id="1"></a>
- 테이블의 프라이머리 키에 대해서만 적용되는 내용이다.
- 프라이머리 키 값에 의해 레코드의 저장 위치가 결정된다
- 이러한 이유로 프라이머리 키 값이 변경된다면 그 레코드의 물리적인 저장 위치가 변경되어야 한다.

<br/>

### `특징`
- InnoDB와 같이 항상 클러스터링 인덱스로 저장되는 테이블은 프라이머리 키 기반의 검색이 매우 빠르며, 대신 레코드의 저장이나 프라이머리 키의 변경이 상대적으로 느리다.

<br/>

### `클러스터링 인덱스 구조`
- 세컨더리 인덱스를 위한 B-Tree의 리프 노드와는 달리, 클러스터링 인덱스의 리프 노드에는 레코드의 모든 칼럼이 같이 저장돼 있다.

<br/>

## **`8.8.2 세컨더리 인덱스에 미치는 영향`**<a id="2"></a>
- MyISAM 테이블이나 MEMORY 테이블에서는 프라이머리 키와 세컨더리 인덱스는 구조적으로 아무런 차이가 없다.
- InnoDB 테이블에서는 클러스터링 키 값이 변경될 때마다 데이터 레코드의 주소가 변경되고 그때마다 해당 테이블의 모든 인덱스에 저장된 주솟값을 변경해야한다.
- 이런 오버헤드를 제거하기 위해 InnoDB 테이블의 모든 세컨더리 인덱스는 해당 레코드가 저장된 주소가 아니라 프라이머리 키 값을 저장하도록 구현돼 있다.

즉, InnoDB 테이블에서 세컨더리를 이용해서 검색하면, 세컨더리 인덱스를 통해 레코드의 프라이머리 키 값을 확인한 후, 프라이머리 키 인덱스를 검색해서 최종 레코드를 가져온다.

<br/>

## **`8.8.3 클러스터링 인덱스의 장점과 단점`**<a id="3"></a>
### **`장점`**
- 프라이머리 키로 검색할 때 처리 성능이 매우 빠름.
- 테이블의 모든 세컨더리 인덱스가 프라이머리 키를 가지고 있기 때문에 인덱스만으로 처리될 수 있는 경우가 많음

<br/>

### **`단점`**
- 테이블의 모든 세컨더리 인덱스가 클러스터링 키를 갖기 때문에 클러스터링 키 값의 크기가 클 경우 전체적으로 인덱스의 크기가 커짐
- 세컨더리 인덱스를 통해 검색할 때 프라이머리 키로 다시 한번 검색해야 하므로 처리 성능이 느림
- INSERT 할 때, 프라이머리 키에 의해 저장 위치가 결정되기 때문에 처리 성능이 느림.
- 프라이머리 키를 변경할 때 레코드를 DELETE 하고 INSERT 하는 작업이 필요하기 때문에 처리성능이 느림

<br/>

## **`8.8.4 클러스터링 테이블 사용 시 주의사항`**<a id="4"></a>
### **`클러스터링 인덱스의 크기`**
클러스터링 테이블의 경우 모든 세컨더리 인덱스가 프라이머리 키 값을 포함한다.
- 따라서 프라이머리 키의 크기가 커지면 세컨더리 인덱스도 자동으로 크기가 커진다. (일반적으로 테이블에 세컨더리 인덱스가 4~5개 정도 생성된다는 것을 고려하면 세컨더리 인덱스 크기는 급격히 증가한다.)

<br/>

### **`가능한 경우 프라이머리 키는 AUTO_INCREMENT 보다는 업무적인 칼럼으로 생성`**
칼럼의 크기가 크더라도 업무적으로 해당 레코드를 대표할 수 있다면 그 칼럼을 프라이머리 키로 설정하는 것이 좋다.

<br/>

### **`프라이머리 키는 반드시 명시할 것`**
InnoDB 테이블에서 프라이머리 키를 정의하지 않으면 InnoDB 스토리지 엔진이 내부적으로 일련번호 칼럼을 추가한다.
- 하지만 자동으로 추가된 칼럼은 사용자에게 보이지 않기 때문에 사용자가 접근 사용할 수 없다.
AUTO_INCREMENT 칼럼을 이용해서라도 프라이머리 키는 생성하는 것을 권장한다.

<br/>

### **`AUIO_INCREMENT 칼럼을 인조 식별자로 사용하는 경우`**
여러 개의 칼럼이 복합적으로 프라이머리 키가 만들어지는 경우 프라이머리 키가 길어질 때가 가끔 있다.  
하지만 프라이머리 키의 크기가 길어도 세컨더리 인덱스가 필요치 않다면 그대로 프라이머리 키를 사용하는 것이 좋다.
- 세컨더리 인덱스도 필요하고 프라이머리 키의 크기도 길다면 AUTO_INCREMENT 칼럼을 추가하고, 이를 프라이머리 키로 설정하면 된다.
- 이렇게 프라이머리 킬를 대체하기 위해 인위적으로 추가된 프라이머리 키를 인조 식별자라고 한다.
- 로그 테이블과 같이 조회보다는 INSERT 위주의 테이블들은 AUTO_INCREMENT 를 이용한 인조 시별자를 프라이머리 키로 설정하는 것이 성능 향상에 도움이 된다.