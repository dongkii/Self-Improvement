# 05. Transaction and Lock

- `잠금(Lock)`와 `트랜잭션`은 서로 비슷한 개념 같지만 `잠금은 동시성을 제어하기 위한 기능`이고 `트랜잭션은 데이터의 정합성을 보장하기 위한 기능`이다.  
- `격리 수준`은 하나의 트랜잭션 내에서 또는 여러 트랜잭션 간의 작업 내용을 어떻게 공유하고 차단할 것인지 결정하는 레벨

# **`5.3 InnoDB 스토리지 엔진 잠금`**
InnoDB 스토리지 엔진은 MySQL에서 제공하는 잠금과는 별개로 스토리지 엔진 내부에서 레코드 기반의 잠금 방식을 탑재하고 있다.  
InnoDB 는 레코드 기반의 잠금 방식 때문에 MyISAM 보다는 훨씬 뛰어난 동시성 처리를 제공할 수 있다. 하지만 이원화된 잠금 처리 탓에 InnoDB 스토리지 엔진에서 사용되는 잠금에 대한 정보는 MySQL 명령을 이용해 접근하기가 상당히 까다롭다.

최근 버전에는 InnoDB의 트랜잭션과 잠금, 그리고 잠금 대기 중인 트랜잭션의 목록을 조회할 수 있는 방법이 도입됐다. MySQL 서버의 information_schema 데이터베이스에 존재하는 `INNODB_WRX`, `INNODB_LOCKS`, `INNODB_LOCK_WAITS`라는 테이블을 조회하면 현재 어떤 트랜잭션이 잠금을 대기하고 있고 해당 잠금을 어느 트랜잭션이 가지고 있는지 확인할 수 있으며, 또한 장시간 잠금을 가지고 있는 클라이언트를 찾아서 종료시킬 수도 있다.

또한 InnoDB의 잠금에 대한 모니터링도 더 강화되면서 Performance Schema를 이용해 InnoDB 스토리지 엔진의 내부 잠금(세마포어)에 대한 모니터링 방법도 추가됐다.

<br/>

## **목차**
- [5.3.1 InnoDB 스토리지 엔진의 잠금](#1)
- [5.3.2 인덱스와 잠금](#2)
- [5.3.3 레코드 수준의 잠금 확인 및 해제](#3)

<br/>

## **`5.3.1 InnoDB 스토리지 엔진의 잠금`**<a id="1"></a>
- InnoDB 스토리지 엔진은 레코드 기반의 잠금 기능을 제공한다.
- 레코드와 레코드 사이의 간격을 잠그는 갭(GAP) 락이라는 것도 존재

### `레코드 락`
- 레코드 자체가 아니라 인덱스의 레코드를 잠금
- 인덱스가 없는 테이블이더라도 내부적으로 잗오 생성된 클러스터 인덱스를 이용해 잠금
- PK 또는 유니크 인덱스에 의한 변경 작업에서는 레코드 락 사용

### `갭 락`
- 레코드 자체가 아닌 레코드와 바로 인접한 레코드 사이의 간격만을 잠그는 것을 의미한다.
- 레코드와 레코드 사이 간격에 새로운 레코드가 INSERT 되는 것을 제어한다.
- 넥스트 키 락의 일부로 자주 사용됨

### `넥스트 키 락`
- 레코드 락과 갭 락을 합쳐놓은 형태
- STATEMENT 포맷의 바이너리 로그를 사용하는 MySQL 서버에서는 REPEATABLE READ 격리 수준을 사용해야 함
- 바이너리 로그에 기록되는 쿼리가 레플리카 서버에 실행될 때 소스 서버에서 만들어 낸 결과와 동일한 결과를 만들어 내도록 보장하는 것이 목적
- 넥스트 키 락과 갭 락으로 인해 데드락이 발생하거나 다른 트랜잭션을 기다리게 만드는 일이 자주 발생
- 바이너리 로그 포맷을 ROW 형태로 바꿔서 넥스트 키 락이나 갭 락을 줄이는 것이 좋음

### `자동 증가 락`
- AUTO_INCREMENT 컬럼이 사용된 테이블에 동시에 여러 레코드 INSERT 되는 경우, 저장되는 각 레코드는 중복되지 않고 저장된 순서대로 증가하는 일련번호 값을 가져야함
- InnoDB 스토리지 엔진에서는 이를 위해 내부적으로 AUTO_INCREMENT 락이라고 하는 테이블 수준의 잠금을 사용
- 자동 증가 값이 증가하면 절대 줄어들지 않는 이유가 이 잠금을 최소화하기 위해
    - INSERT 쿼리라 실패해도 한 번 증가된 AUTO_INCREMENT 값은 다시 줄어들지 않고 그대로 남는다.
- INSERT, REPLACE 쿼리 문장처럼 `새로운 레코드를 저장하는 쿼리`에서만 필요하다.
- InnoDB의 다른 잠금(레코드 락 등)과 달리 `트랜잭션과 관계 없이` INSERT, REPLACE 문장에서 AUTO_INCREMENT 값을 가져오는 순간만 락이 걸렸다가 즉시 해제된다.

<br/>

- MySQL 5.1 이상부터 innodb_autoinc_lock_mode라는 시스템 변수를 이용해 자동 증가 락의 작동 방식을 변경할 수 있다.

- innodb_autoinc_lock_mode = 0
    - MySQL 5.0 과 동일한 잠금 방식, 모든 INSERT 문장은 자동 증가 락을 사용한다.
- innodb_autoinc_lock_mode = 1
    - INSERT 되는 레코드 수를 정확히 예측할 수 있으면, 자동 증가 락보다 가볍고 빠른 래치(뮤텍스)를 이용해 처리한다.
    - INSERT ... SELECT 처럼 건수를 예측할 수 없을 때는 자동 증가 락을 사용한다.
    - INSERT 되는 레코드는 연속된 증가 값을 갖으므로, 해당 설정을 `연속 모드(Concecutive Mode)`라고도 한다.
    - 대량 INSERT가 수행될 때 InnoDB는 여러 개의 자동 증가 값을 한 번에 할당 받아 INSERT 되는 레코드에 사용한다.
    - `단점 : 한번에 할당 받은 값들이 남아서 사용되지 못하면 폐기하므로 대량 INSERT 문장의 실행 후 INSERT 되는 레코드의 자동 증가 값은 연속되지 않고 누락된 값이 발생할 수 있다.`
- innodb_autoinc_lock_mode = 2
    - 절대 자동 증가 락을 걸지 않고 경량화된 래치(뮤텍스)를 사용한다.
    - 하나의 INSERT 문장으로 INSERT 되는 레코드라도 연속된 자동 증가 값을 보장하지 않는다.
    - 따라서 `인터리브드 모드(Interleaved Mode)`라고도 한다.
    - MySQL 8.0 버전의 기본값이다. 바이너리 로그 포맷의 기본값이 ROW 포맷이 되었기 때문이다.
    - ROW 포맷이 아니라 STATEMENT 포맷의 바이너리 로그를 사용한다면 설정 값을 1로 변경해서 사용할 것을 권장한다.
    - `장점 : INSERT ... SELECT와 같은 대량 INSERT 문장이 실행되는 중에도 다른 커넥션에서 INSERT를 수행할 수 있으므로 동시성이 증가한다.`
    - `단점 : 이 설정에서 작동하는 자동 증가 기능은 유니크한 값이 생성된다는 것만 보장하므로, STATEMENT 포맷 바이너리 로그를 사용하여 복제하는 소스 서버와 레플리카 서버의 자동 증가 값이 달라질 수 있다.`

<br/>

## **`5.3.2 인덱스와 잠금`**<a id="2"></a>
- InnoDB의 잠금은 인덱스를 잠그는 방식이므로, 변경할 레코드를 찾기 위해 검색한 인덱스의 레코드에 모두 락을 걸어야 한다.
- 주의사항 : UPDATE를 위한 적절한 인덱스가 준비돼 있어야 한다.
- 예시
    - 253개의 레코드가 있는 사원 테이블에서 first_name = 'Geogi', last_name = 'Klassen'인 레코드를 검색한다고 가정하자.
    - first_name 은 인덱스, last_name은 인덱스가 아니기 때문에 first_name = 'Geogi'에 해당하는 레코드 253건이 모두 잠긴다.
<br/>

## **`5.3.3 레코드 수준의 잠금 확인 및 해제`**<a id="3"></a>
- 레코드 수준 잠금의 문제점 : 레코드 각각에 잠금이 걸리므로 그 레코드가 자주 사용되지 않는다면 오랜 시간 동안 잠겨진 상태로 있어도 잘 발견되지 않는다.

- MySQL 5.1 부터 information_schema 라는 DB에 INNODB_TRX, INNODB_LOCKS, INNODB_LOCK_WAITS 테이블을 통해 레코드 잠금과 잠금 대기에 대한 조회가 가능하다.
    - 쿼리 하나만 실행하면 잠금과 잠금 대기를 볼 수 있다.
    - 강제로 잠ㄱ므을 해제하려면 KILL 명령을 이용해 MySQL 서버의 프로세스를 강제 종료한다.

<br/>

- MySQL 8.0 부터는 information_schema의 정보들이 조금씩 Deprecated되고, `performance_schema의 data_locks와 data_lock_waits 테이블로 대체`되고 있다.

