# 스프링 핵심 원리 - 기본편


## 스프링 프레임워크(Spring Framework)
- **핵심 기술 :** 스프링 DI컨테이너, AOP, 이벤트, 기타
- **웹 기술 :** 스프링 MVC, 스프링 WebFlux
- **데이터 접근 기술 :** 트랜잭션, JDBC, ORM 지원, XML 지원
- **기술 통합 :** 캐시, 이메일, 원격접근, 스케줄링
- **테스트 :** 스프링 기반 테스트 지원
- **언어 :** 코틀린, 그루비
- 최근에는 스프링 부트를 통해서 스프링 프레임워크의 기술들을 편리하게 사용

## 스프링 부트(Spring boot)
- **스프링을 편리하게 사용할 수 있도록 지원, 최근에는 기본으로 사용**
- 단독으로 실행할 수 있는 스프링 애플리케이션을 쉽게 생성
- Tomcat 같은 웹 서버를 내장해서 별도의 웹 서버를 설치하지 않아도 됨
- 손쉬운 빌드 구성을 위한 starter 종속성 제공
- 스프링과 3rd parth(외부) 라이브러리 자동 구성
- 메트릭, 상태 확인, 외부 구성 같은 프로덕션 준비 기능 제공
- 관례에 의한 간결한 설정

## 스프링의 진짜 핵심
- 스프링은 자바 언어 기반의 프레임워크
- 자바 언어의 가장 큰 특징 - **`객체 지향 언어`**
- 스프링은 객체 지향 언어가 가진 강력한 특징을 살려내는 프레임워크
- 스프링은 **`좋은 객체 지향`** 애플리케이션을 개발할 수 있게 도와주는 프레임워크

## 객체 지향 특징
- 추상화
- 캡슐화
- 상속
- **`다형성(Polymorphism)`**

## 객체 지향 프로그래밍
- 객체 지향 프로그래밍은 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러개의 독립된 단위, 즉 `"객체"`들의 `모임`으로 파악하고자 하는 것이다. 각각의 `객체`는 `메시지`를 주고받고, 데이터를 처리할 수 있다.

- 객체 지향 프로그래밍은 프로그램을 `유연`하고 `변경`이 용이하게 만들기 때문에 대규모 소프트웨어 개발에 많이 사용된다.

## 다형성의 본질
- 인터페이스를 구현한 객체 인스턴스를 `실행 시점`에 `유연`하게 `변경`할 수 있다.
- 다형성의 본질을 이해하려면 `협력`이라는 객체사이의 관계에서 시작해야한다.
- **`클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경할 수 있다.`**

## 스프링과 객체지향
- 다형성이 가장 중요하다
- 스프링은 다형성을 극대화해서 이용할 수 있게 도와준다.
- 스프링에서 이야기하는 제어의 역전(IoC), 의존관계 주입(DI)은 다형성을 활용해서 역할과 구현을 편리하게 다룰 수 있도록 지원한다.
- 스프링을 사용하면 마치 레고 블럭 조립하듯이! 공연 무대의 배우를 선택하듯이! 구현을 편리하게 변경할 수 있다.

## SOLID - 좋은 객체 지향 설계의 5가지 원칙
- `SRP` : 단일 책임 원칙 (Single Responsibility Principle)
- `OCP` : 개방-폐쇄 원칙 (Open/Closed Principle)
- `LSP` : 리스코프 치환 원칙 (Liskov Substitution Principle)
- `ISP` : 인터페이스 분리 원칙 (Interface Segregation Principle)
- `DIP` : 의존관계 역전 원칙 (Dependency Inversion Principle)

## SRP 단일 책임 원칙 (Single Responsibility Principle)
- 한 클래스는 하나의 책임만 가져야 한다.
- 하나의 책임이라는 것은 모호하다.
  - 클 수 있고, 작을 수 있다.
  - 문맥과 상황에 따라 다르다.
- `중요한 기준은 변경`이다. 변경이 있을 때 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것
- ex) UI 변경, 객체의 생성과 사용을 분리

## OCP 개방-폐쇄 원칙 (Open/Closed Principle)
- 소프트웨어 요소는 `확장에는 열려` 있으나 `변경에는 닫혀` 있어야 한다.
- `다형성`을 활용
- **`인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현`**
- 지금까지 배운 역할과 구현의 분리를 생각

## OCP 개방-폐쇄 원칙 문제점
- MemberService 클라이언트가 구현 클래스를 직접 선택
  - MemberRepository m = new MemoryMemberRepository(); // 기존 코드
  - MemberRepository m = new JdbcMemberRepository(); // 변경 코드
- `구현 객체를 변경하려면 클라이언트 코드를 변경해야 한다.`
- `분명 다형성을 사용했지만 OCP 원칙을 지킬 수 없다.`
- 객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요하다.

## LSP 리스코프 치환 원칙 (Liskov Substitution Principle)
- 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야한다.
- 다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다는 것, 다형성을 지원하기 위한 원칙, 인터페이스를 구현한 구현체는 믿고 사용하려면, 이 원칙이 필요하다.
- 단순히 컴파일에 성공하는 것을 넘어서는 이야기

## ISP 인터페이스 분리 원칙 (Interface Segregation Principle)
- 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
- 자동차 인터페이스 -> 운전 인터페이스, 정비 인터페이스로 분리
- 사용자 클라이언트 -> 운전자 클라이언트, 정비사 클라이언트로 분리
- 분리하면 정비 인터페이스 자체가 변해도 운전자 클라이언트에 영향을 주지 않음
- 인터페이스가 명확해지고, 대체 가능성이 높아진다.

## DIP 의존관계 역전 원칙 (Dependency Inversion Principle)
- 프로그래머는 "추상화에 의존해야지, 구체화에 의존하면 안된다." 의존성 주입은 이 원칙을 따르는 방법 중 하나다.
- 쉽게 이야기해서 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻
- 앞에서 이야기한 `역할(Role)에 의존하게 해야 한다는 것과 같다.` 객체 세상도 클라이언트가 인터페이스에 의존해야 유연하게 구현체를 변경할 수 있다! 구현체에 의존하게 되면 변경이 아주 어려워진다.
- 그런데 OCP에서 설명한 MemberService는 인터페이스에 의존하지만, 구현 클래스도 동시에 의존한다.
- MemberService 클라이언트가 구현 클래스를 직접 선택
  - MemberRepository m = new `MemoryMemberRepository();`
- **`DIP 위반`**

## 핵심 정리
- 객체 지향의 핵심은 다형성
- 다형성 만으로는 쉽게 부품을 갈아 끼우듯이 개발할 수 없다.
- 다형성 만으로는 구현 객체를 변경할 때 클라이언트 코드도 함께 변경된다.
- `다형성 만으로는 OCP, DIP를 지킬 수 없다.`


## 스프링이란
- `스프링은 다음 기술로 다형성 + OCP, DIP를 가능하게 지원`
  - DI(Dependency Injection) : 의존관계, 의존성 주입
  - DI 컨테이너 제공
- `클라이언트 코드의 변경 없이 기능 확장`
- 쉽게 부품을 교체하듯이 개발


## 정리
- 모든 설계에 `역할`과 `구현`을 분리
- 역할 - 배역, 자동차 / 구현 - 로미오역, 줄리엣역, K3, 아반떼
- 애플리케이션 설계도 공연을 설계 하듯이 배역만 만들어두고, 배우는 언제든지 `유연`하게 `변경`할 수 있도록 만드는 것이 좋은 객체 지향 설계다.
- 이상적으로는 모든 설계에 인터페이스를 부여하자.

## 제어의 역전 IoC (Inversion of Control)
- 기존 프로그램은 클라이언트 구현 객체가 스스로 필요한 서버 구현 객체를 생성하고, 연결하고, 실행했다. 한마디로 구현 객체가 프로그램의 제어 흐름을 스스로 조종했다. 개발자 입장에서는 자연스러운 흐름이다.
- 반면에 AppConfig가 등장한 이후에 구현 객체는 자신의 로직을 실행하는 역할만 담당한다. 프로그램의 제어 흐름은 이제 AppConfig가 가져간다. 예를 들어서 '`OrderServiceImpl`'은 필요한 인터페이스들을 호출하지만 어떤 구현 객체들이 실행될지 모른다.
- 프로그램에 대한 제어 흐름에 대한 권한은 모두 AppConfig가 가지고 있다. 심지어 '`OrderServiceImpl`'도 AppConfig가 생성한다. 그리고 AppConfig는 '`OrderServiceImpl`'이 아닌 `OrderService` 인터페이스의 다른 구현 객체를 생성하고 실행할 수도 있다. 그런 사실도 모른체 '`OrderServiceImpl`'은 묵묵히 자신의 로직을 실행할 뿐이다.
- 이렇듯 프로그램의 제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는 것을 **`제어의 역전(IOC)`** 이라 한다.

## 프레임워크 vs 라이브러리
- 프레임워크가 내가 작성한 코드를 제어하고, 대신 실행하면 그것은 프레임워크가 맞다. (JUnit)
- 반면에 내가 작성한 코드가 직접 제어의 흐름을 담당한다면 그것은 프레임워크가 아니라 라이브러리다.

## 의존관계 주입 ( DI : Dependency Injection )
- '`OrderServiceImpl`'은 '`DiscountPolicy`' 인터페이스에 의존한다. 실제 어떤 구현 객체가 사용될지는 모른다.
- 의존관계는 **`정적인 클래스 의존 관계와, 실행 시점에 결정되는 동적인 객체(인스턴스) 의존관계`** 둘을 분리해서 생각해야 한다.

```md
### 정적인 클래스 의존 관계
클래스가 사용하는 import 코드만 보고 의존관계를 쉽게 판단할 수 있다. 정적인 의존관계는 애플리케이션을 실행하지 않아도 분석 할 수 있다.
```

```md
### 동적인 객체 인스턴스 의존관계
애플리케이션 실행 시점에 실제 생성된 객체 인스턴스의 참조가 연결된 의존 관계다.

- 애플리케이션 실행 시점(런타임)에 외부에서 실제 구현 객체를 생성하고 클라이언트에 전달해서 클라이언트와 서버의 실제 의존관계가 연결되는 것을 의존관계 주입이라 한다.
- 객체 인스턴스를 생성하고, 그 참조값을 전달해서 연결된다.
- 의존관계 주입을 사용하면 클라이언트 코드를 변경하지 않고, 클라이언트가 호출하는 대상의 타입 인스턴스를 변경할 수 있다.
- 의존관계 주입을 사용하면 정적인 클래스 의존관계를 변경하지 않고, 동적인 객체 인스턴스 의존관계를 쉽게 변경할 수 있다.
```

## IoC 컨테이너, DI 컨테이너
- AppConfig 처럼 객체를 생성하고 관리하면서 의존관계를 연결해주는 것을 IoC 컨테이너 또는 **`DI 컨테이너`** 라 한다.
- 의존관계 주입에 초점을 맞추어 최근에는 주로 DI 컨테이너라 한다.
- 또는 어셈블러, 오브젝트 팩토리 등으로 불리기도 한다.

## **`싱글톤 패턴`**
- 클래스의 인스턴스가 딱 1개만 생성되는 것을 보장하는 디자인 패턴이다.
- 그래서 객체 인스턴스를 2개 이상 생성하지 못하도록 막아야 한다.
  - private 생성자를 사용해서 외부에서 임의로 new 키워드를 사용하지 못하도록 막아야한다.

## **`싱글톤 패턴의 문제점`**
- 싱글톤 패턴을 구현하는 코드 자체가 많이 들어간다.
- 의존관계상 클라이언트가 구체 클래스에 의존한다 -> DIP를 위반한다.
- 클라이언트가 구체 클래스에 의존해서 OCP 원칙을 위반할 가능성이 높다.
- 테스트하기 어렵다.
- 내부 속성을 변경하거나 초기화하기 어렵다.
- private 생성자로 자식 클래스를 만들기 어렵다.
- 결론적으로 유연성이 떨어진다.
- 안티패턴으로 불리기도 한다.

## 싱글톤 컨테이너
- 스프링 컨테이너는 싱글턴 패턴을 적용하지 않아도, 객체 인스턴스를 싱글톤으로 관리한다.
  - 컨테이너는 객체를 하나만 생성해서 관리한다.
- 스프링 컨테이너는 싱글톤 컨테이너 역할을 한다. 싱글톤 객체를 생성하고 관리하는 기능을 싱글톤 레지스트리라 한다.
- 스프링 컨테이너의 이런 기능 덕분에 싱글톤 패턴의 모든 단점을 해결하면서 객체를 싱글톤으로 유지할 수 있다.
  - 싱글톤 패턴을 위한 지저분한 코드가 들어가지 않아도 된다.
  - DIP, OCP, 테스트, private 생성자로부터 자유롭게 싱글톤을 사용할 수 있다.

## **`싱글톤 방식의 주의점`**
- 싱글톤 패턴이든, 스프링 같은 싱글톤 컨테이너를 사용하든, 객체 인스턴스를 하나만 생성해서 공유하는 싱글톤 방식은 여러 클라이언트가 하나의 객체 인스턴스를 공유하기 때문에 싱글톤 객체는 상태를 `유지(stateful)`하게 설계하면 안된다.
- `무상태(stateless)`로 설계해야된다.
  - 특정 클라이언트에 의존적인 필드가 있으면 안된다.
  - 특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안된다.
  - 가급적 읽기만 가능해야 한다.
  - 필드 대신에 자바에서 공유되지 않는, 지역변수, 파라미터, ThreadLocal 등을 사용해야한다.
- 스프링 빈의 필드에 공유 값을 설정하면 정말 큰 장애가 발생할 수 있으니 조심해야한다.

## 컴포넌트 스캔 탐색 위치와 기본 스캔 대상
  - 모든 자바 클래스를 다 컴포넌트 스캔하면 시간이 오래 걸리기 때문에 필요한 위치부터 탐색을 시작하도록 설정
  - basePackages : 탐색할 패키지의 시작 위치를 지정한다. 이 패키지를 포함해서 하위 패키지를 모두 탐색한다.
    - basePackages = {"hello.core", "hello.service"} 이렇게 두개 이상의 시작 위치도 지정 가능
  - basePackagesClasses : 지정한 클래스의 패키지를 탐색 시작위치로 지정한다.
  - 만약 지정하지 않을 경우 Default 탐색 위치는 @ComponentScan 이 붙은 설정정보 클래스의 패키지가 시작위치가 된다.

```java
@ComponentScan{
  basePackages = "hello.core.member",
  basePackageClasses = AutoAppConfig.class
}
```

## 컴포넌트 스캔 기본 대상
컴포넌트 스캔은 @Component 뿐만 아니라 다음과 내용도 추가로 대상에 포함한다.
  - @Component : 컴포넌트 스캔에서 사용
  - @Controller : 스프링 MVC 컨트롤러에서 사용
  - @Service : 스프링 비지니스 로직에서 사용
  - @Repository : 스프링 데이터 접근 계층에서 사용
  - @Configuration : 스프링 설정 정보에서 사용

## 다음 어노테이션이 있으면 스프링의 부가기능도 수행
- @Controller : 스프링 MVC 컨트롤러로 인식
- @Repository : 스프링 데이터 접근 계층으로 인식하고, 데이터 계층의 예외를 스프링 예외로 변환해준다.
- @Configuration : 앞서 보았듯이 스프링 설정정보로 인식하고, 스프링 빈이 싱글톤을 유지하도록 추가 처리를 한다.
- @Service : 개발자들이 '핵심 비즈니스 로직이 여기에 있겠구나'라고 비즈니스 계층을 인식하는데 도움이 된다.