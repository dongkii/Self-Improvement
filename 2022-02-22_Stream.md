# Stream [JAVA]

## **목차**
- [1. 스트림(Stream) 이란?](#1)
- [2. 생성하기](#2)
    - [2-1. 배열 / 컬렉션 / 빈 스트림](#2-1)
    - [2-2. Stream.builder() / Stream.generate() / Stream.iterate()](#2-2)
    - [2-3. 기본 타입형 / String / 파일스트림](#2-3)
    - [2-4. 병렬 스트림 / 스트림 연결하기](#2-4)
- [3. 가공하기](#3)
    - [3-1. Filtering](#3-1)
    - [3-2. Mapping](#3-2)
    - [3-3. Sorting](#3-3)
    - [3-4. Iterating](#3-4)
- [4. 결과 만들기](#4)
    - [4-1. Calulating](#4-1)
    - [4-2. Reduction](#4-2)
    - [4-3. Collecting](#4-3)
    - [4-4. Matching](#4-4)
    - [4-5. Iterating](#4-5)


## 1. 스트림(Stream) 이란?<a id="1"></a>
> 자바 8에서 추가한 `스트림(Stream)`은 람다를 활용할 수 있는 기술 중 하나이다. 자바 8이전에는 배열 또는 컬렉션 인스턴스를 다루는 방법은 `for` 또는 `foreach` 문을 돌면서 요소 하나씩을 꺼내서 다루는 방법이었다. 간단한 경우라면 상관없지만 로직이 복잡해질수록 코드의 양이 많아져 여러 로직이 섞이게 되고, 메소드를 나눌 경우 루프를 여러번 도는 경우가 발생한다.

스트림은 `'데이터의 흐름'`이다. 배열 또는 컬렉션 인스턴스에 함수 여러 개를 조합해서 원하는 결과를 필터링하고 가공된 결과를 얻을 수 있다. 또한 람다를 이용해서 코드의 양을 줄이고 간결하게 표현할 수 있다. 즉, 배열과 컬렉션을 함수형으로 처리할 수 있다.

또 하나의 장점은 간단하게 `병렬처리(multi-threading)`가 가능하다는 점이다. 하나의 작업을 둘 이상의 작업으로 잘게 나눠서 동시에 진행하는 것을 `병렬처리(parallel processing)`라고 한다. 즉 쓰레드를 이용해 많은 요소들을 빠르게 처리할 수 있다.

스트림에 대한 내용은 크게 세 가지로 나눌 수 있다.
1. `생성하기` : 스트림 인스턴스 생성
2. `가공하기` : 필터링(filtering)및 맵핑(mapping)등 원하는 결과를 만들어가는 중간 작업(intermediate operations)
3. `결과 만들기` : 최종적으로 결과를 만들어내는 작업(terminal operations)

> 전체 -> 맵핑 -> 필터링1 -> 필터링2 -> 결과만들기 -> 결과물

<br/>
<br/>

## 2. 생성하기 <a id="2"></a>  
> 보통 배열과 컬렉션을 이용해서 스트림을 만들지만 이 외에도 다양한 방법으로 스트림을 만들 수 있다.
## 2-1. 배열 / 컬렉션 / 빈 스트림 <a id="2-1"></a>

- 배열 스트림  
    스트림을 이용하기 위해서는 먼저 생성을 해야 한다. 스트림은 배열 또는 컬렉션 인스턴스를 이용해서 생성할 수 있다. 배열은 다음과 같이 `Arrays.stream` 메소드를 사용

    ```java
    String[] arr = new String[]{"a", "b", "c"};
    Stream<String> stream = Arrays.stream(arr);
    Stream<String> streamOfArrayPart =
        Arrays.stream(arr, 1, 3); // 1~2 요소 [b, c]
    ```

- 컬렉션 스트림  
    컬렉션 타입(Collection, List, Set)의 경우 인터페이스에 추가된 디폴트 메소드 `stream`을 이용해서 스트림을 만들 수 있다.
    ```java
    public interface Collection<E> extends Iterable<E> {
        default Stream<E> stream() {
            return StreamSupport.stream(spliterator(), false);
        }
    }
    ```
    그러면 다음과 같이 생성할 수 있다.
    ```java
    List<String> list = Arrays.asList("a", "b", "c");
    Stream<String> stream = list.stream();
    Stream<String> parallelStream = list.parallelStream(); // 병렬 처리 스트림
    ```

- 비어 있는 스트림  
    비어있는 스트림(empty streams)도 생성할 수 있다. 언제 빈 스트림이 필요한가? 빈 스트림은 요소가 없을 때 null 대신 사용할 수 있다.
    ```java
    public Stream<String> streamOf(List<String> list) {
        return list == null || list.isEmpty() ? Stream.empty() : list.stream();
    }
    ```

<br/>
<br/>

## 2-2. Stream.builder() / Stream.generate() / Stream.iterate() <a id="2-2"></a>

- Stream.builder()  
    빌더(Builder)를 사용하면 스트림에 직접적으로 원하는 값을 넣을 수 있다. 마지막에 build 메소드로 스트림을 리턴한다.
    ```java
    Stream<String> builderStream =
        Stream.builder()
        .add("Eric").add("Elena").add("java")
        .build();       // [Eric, Elena, Java]
    ```

- Stream.generate()  
    `generate` 메소드를 이용하면 `Supplier<T>`에 해당하는 람다로 값을 넣을 수 있다. `Supplier<T>`는 인자는 없고 리턴값만 있는 함수형 인터페이스이다. 람다에서 리턴하는 값이 들어간다.
    ```java
    public static<T> Stream<T> generate(Supplier<T> s) { ... }
    ```

    이때 생성되는 스트림은 크기가 정해져있지 않고 무한(infinite)하기 때문에 특정 사이즈로 최대 크기를 제한해야 한다.

    ```java
    Stream<String> generatedStream = 
        Stream.generate(() -> "gen").limit(5);  // [el, el, el, el, el]
    ```

    5개의 "gen" 이 들어간 스트림이 생성된다.

- Stream.iterate()  
    `iterate` 메소드를 이용하면 초기값과 해당 값을 다루는 람다를 이용해서 스트림에 들어갈 요소를 만든다. 다음 예제에서는 30이 초기값이고 값이 2씩 증가하는 값들이 들어가게 된다. 즉 요소가 다음 요소의 인풋으로 들어간다. 이 방법도 스트림의 사이즈가 무한하기 때문에 특정 사이즈로 제한해야 한다.

    ```java
    Stream<Integer> iteratedStream =
        Stream.iterate(30, n -> n + 2).limit(5); // [30, 32, 34, 36, 38]
    ```

<br/>
<br/>

## 2-3. 기본 타입형 / String / 파일스트림 <a id="2-3"></a>

- 기본 타입형 스트림  
    물론 제네릭을 사용하면 리스트나 배열을 이용해서 기본 타입(int, long, double) 스트림을 생성할 수 있다.
    하지만 제네릭을 사용하지 않고 직접적으로 해당 타입의 스트림을 다룰 수도 있다. `range`와 `rangeClosed`는 범위의 차이이다. 두 번째 인자인 종료 지점이 포함되느냐 안되느냐의 차이

    ```java
    IntStream intStream = IntStream.range(1, 5); // [1, 2, 3, 4]
    LongStream longStream = LongStream.rangeClosed(1, 5); // [1, 2, 3, 4, 5]
    ```

    제네릭을 사용하지 않기 때문에 불필요한 `오토박싱(auto-boxing)`이 일어나지 않는다. 필요한 경우 boxed 메소드를 사용해 `박싱(boxing)` 가능

    ```java
    Stream<Integer> boxedIntStream = IntStream.range(1, 5).boxed();
    ```
    
    Java 8 의 Random 클래스는 난수를 가지고 세 가지 타입의 스트림(IntStream, LongStream, DoubleStream)을 만들어낼 수 있다. 쉽게 난수 스트림을 생성해서 여러가지 후속 작업을 취할 수 있어 유용하다.

    ```java
    DoubleStream doubles = new Random().doubles(3); // 난수 3개 생성
    ```

- 문자열 스트림  
    문자열을 이용해서 스트림을 생성할 수도 있다. 다음은 문자열의 각 문자(char)를 `IntStream`으로 변환한 예제이다. `char`는 문자이지만 본질적으로는 숫자이기 때문에 가능하다.

    ```java
    IntStream charsStream = 
        "Stream".chars();   // [83, 116, 114, 101, 97,109]
    ```

    다음은 정규표현식(RegEx)을 이용해서 문자열을 자르고, 각 요소들로 스트림을 만든 예제이다.

    ```java
    Stream<String> stringStream =
        Pattern.compile(", ").splitAsStream("Eric, Elena, Java");
        // [Eric, Elena, Java]
    ```

- 파일 스트림  
    자바 NIO의 `Files` 클래스의 `lines` 메소드는 해당 파일의 각 라인을 문자열 타입의 스트림으로 만들어 준다.

    ```java
    Stream<String> lineStream =
        Files.lines(Paths.get("file.txt"),
                    Charset.forName("UTF-8"));
    ```

<br/>
<br/>

## 2-4. 병렬 스트림 / 스트림 연결하기 <a id="2-4"></a>

- 병렬 스트림 (Parallel Stream)  
    스트림 생성 시 사용하는 `stream` 대신 `parallelStream` 메소드를 사용해서 병렬 스트림을 쉽게 생성할 수 있다. 내부적으로는 쓰레드를 처리하기 위해 자바 7부터 도입된 Fork/Join framework 를 사용한다.

    ```java
    // 병렬 스트림 생성
    Stream<Product> parallelStream = productList.parallelStream();

    // 병렬 여부 확인
    boolean isParallel = parallelStream.isParallel();
    ```

    따라서 다음 코드는 각 작업을 쓰레드를 이용해 병렬 처리된다.

    ```java
    boolean isMany = parallelStream
            .map(product -> product.getAmount() * 10)
            .anyMatch(amount -> amount > 200);
    ```

    다음은 배열을 이용해서 병렬 스트림을 생성하는 경우이다.

    ```java
    Arrays.stream(arr).parallel();
    ```

    컬렉션과 배열이 아닌 경우는 다음과 같이 `parallel` 메소드를 이용해서 처리한다.

    ```java
    IntStream intStream = IntStream.range(1, 150).parallel();
    boolean isParallel = intStream.isParallel();
    ```

    다시 시퀀셜(sequential) 모드로 돌리고 싶다면 다음처럼 `sequential` 메소드를 사용한다. 뒤에서 한번 더 다루겠지만 반드시 병렬 스트림이 좋은 것은 아니다.

    ```java
    IntStream intStream = intStream.sequential();
    boolean isParallel = intStream.isParallel();
    ```

- 스트림 연결하기  
    `Stream.concat` 메소드를 이용해 두 개의 스트림을 연결해서 새로운 스트림을 만들어낼 수 있다.

    ```java
    Stream<String> stream1 = Stream.of("Java", "Scala", "Groovy");
    Stream<String> stream2 = Stream.of("Python", "Go", "Swift");
    Stream<String> concat = Stream.concat(stream1, stream2);
    // [Java, Scala, Groovy, Python, Go, Swift]
    ```

<br/>
<br/>

## 3. 가공하기 <a id="3"></a>
전체 요소 중에서 다음과 같은 API를 이용해서 내가 원하는 것만 뽑아낼 수 있다. 이러한 가공 단계를 `중간 작업(intermediate operations)`이라고 하는데, 이러한 작업은 스트림을 리턴하기 때문에 여러 작업을 이어 붙여서(chaining) 작성할 수 있다.

```java
List<String> names = Arrays.asList("Eric", "Elena", "Java");
```

아래 나오는 예제 코드는 위와 같은 리스트를 대상으로 한다.

## 3-1. Filtering <a id="3-1"></a>

 - 필터(filter)는 스트림 내 요소들을 하나씩 평가해서 걸러내는 작업이다. 인자로 받는 Predicate 는 boolean을 리턴하는 함수형 인터페이스로 평가식이 들어가게 된다.

```java
Stream<T> filter(Predicate<? super T> predicate);
```

아래는 간단한 예제이다.

```java
Stream<String> stream = names.stream()
                                .filter(name -> name.contains("a"));
                                // [Elena, Java]
```

스트림의 각 요소에 대해서 평가식을 실행하게 되고 'a'가 들어간 이름만 들어간 스트림이 리턴된다.

<br/>
<br/>

## 3-2. Mapping <a id="3-2"></a>


## 3-3. Sorting <a id="3-3"></a>
## 3-4. Iterating <a id="3-4"></a>
## 4. 결과 만들기 <a id="4"></a>
## 4-1. Calulating <a id="4-1"></a>
## 4-2. Reduction <a id="4-2"></a>
## 4-3. Collecting <a id="4-3"></a>
## 4-4. Matching <a id="4-4"></a>
## 4-5. Iterating <a id="4-5"></a>